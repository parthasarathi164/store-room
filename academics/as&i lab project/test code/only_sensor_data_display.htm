<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aircraft AHRS Display (Live Data)</title>
    <!-- 1. Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load a good "tech" font (Orbitron) from Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    
    <style>
        /* 3. Apply the font and a dark theme */
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            background-color: #000;
            border-radius: 8px;
            border: 2px solid #333;
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-2xl font-bold text-cyan-300 mb-4">AI Aircraft AHRS (LIVE DATA)</h1>

    <!-- 4. The Canvas element where we will draw the PFD --><div class="w-full max-w-5xl aspect-[16/10] shadow-2xl">
        <canvas id="pfdCanvas"></canvas>
    </div>

    <!-- 5. Connection Button and Status Message -->
    <button id="connectButton" class="mt-4 px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 transition duration-300">
        Connect to Nucleo Board
    </button>
    <p id="statusMessage" class="mt-4 text-gray-400">Status: Disconnected</p>


    <script>
        // === SCRIPT START ===

        // --- 1. SETUP ---
        const canvas = document.getElementById('pfdCanvas');
        const ctx = canvas.getContext('2d');
        const connectButton = document.getElementById('connectButton');
        const statusMessage = document.getElementById('statusMessage');

        // Smoothing factor (0.1 = 10% new data, 90% old data)
        const smoothingFactor = 0.1;

        // --- 2. SENSOR DATA ---
        const sensorData = {
            pitch: 0,       // Degrees (From Nucleo)
            roll: 0,        // Degrees (From Nucleo)
            rollRate: 0,    // Degrees per second (From Nucleo)
        };
        
        // --- [REMOVED] Simulation object ---
        
        // --- 3. WEB SERIAL API ---
        let port;
        let reader;
        let lineBuffer = '';

        connectButton.addEventListener('click', async () => {
            if (port) {
                // Disconnect
                try {
                    await reader.cancel();
                    await port.close();
                } catch (error) {
                    console.warn("Disconnection error: ", error);
                }
                port = null;
                reader = null;
                statusMessage.textContent = 'Status: Disconnected';
                connectButton.textContent = 'Connect to Nucleo Board';
                connectButton.classList.replace('bg-red-600', 'bg-blue-600');
                connectButton.classList.replace('hover:bg-red-700', 'hover:bg-blue-700');
            } else {
                // Connect
                try {
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 115200 }); 
                    statusMessage.textContent = 'Status: Connecting...';
                    
                    const textDecoder = new TextDecoderStream();
                    port.readable.pipeTo(textDecoder.writable);
                    reader = textDecoder.readable.getReader();

                    connectButton.textContent = 'Disconnect';
                    connectButton.classList.replace('bg-blue-600', 'bg-red-600');
                    connectButton.classList.replace('hover:bg-blue-700', 'hover:bg-red-700');
                    statusMessage.textContent = 'Status: Connected! Waiting for data...';

                    readSerialLoop();

                } catch (error) {
                    console.error('There was an error connecting to the serial port:', error);
                    statusMessage.textContent = `Error: ${error.message}`;
                }
            }
        });

        async function readSerialLoop() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        reader.releaseLock();
                        break;
                    }
                    
                    lineBuffer += value;

                    let newlineIndex;
                    while ((newlineIndex = lineBuffer.indexOf('\n')) !== -1) {
                        const completeLine = lineBuffer.substring(0, newlineIndex + 1);
                        lineBuffer = lineBuffer.substring(newlineIndex + 1);

                        try {
                            const jsonData = JSON.parse(completeLine);
                            
                            // Apply smoothing filter to incoming data
                            if (jsonData.pitch !== undefined) {
                                sensorData.pitch = (jsonData.pitch * smoothingFactor) + (sensorData.pitch * (1.0 - smoothingFactor));
                            }
                            if (jsonData.roll !== undefined) {
                                sensorData.roll = (jsonData.roll * smoothingFactor) + (sensorData.roll * (1.0 - smoothingFactor));
                            }
                            if (jsonData.rollRate !== undefined) {
                                sensorData.rollRate = (jsonData.rollRate * smoothingFactor) + (sensorData.rollRate * (1.0 - smoothingFactor));
                            }
                            
                            if (statusMessage.textContent !== 'Status: Receiving Live Data') {
                                statusMessage.textContent = 'Status: Receiving Live Data';
                                statusMessage.classList.add('text-green-400');
                            }

                        } catch (e) {
                            console.warn('Serial Read: Could not parse JSON line:', completeLine, e);
                        }
                    }
                }
            } catch (error) {
                console.error('Read loop error:', error);
                if (!port.readable) {
                    statusMessage.textContent = 'Status: Disconnected (Port closed)';
                } else {
                    statusMessage.textContent = `Error: ${error.message}`;
                }
                port = null;
                reader = null;
                connectButton.textContent = 'Connect to Nucleo Board';
                connectButton.classList.replace('bg-red-600', 'bg-blue-600');
                connectButton.classList.replace('hover:bg-red-700', 'hover:bg-blue-700');
            }
        }


        // --- 4. RESIZE AND INITIALIZE ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 5. [REMOVED] FAKE SENSOR DATA SIMULATOR ---
        
        // --- 6. MAIN DRAWING LOOP ---
        function drawPFD() {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            // Call component drawing functions
            drawAttitudeIndicator(w, h);
            drawAircraftSymbol(w, h);
            // --- [REMOVED] drawHeadingIndicator ---
            drawRollRateIndicator(w, h);
            
            // Request the next frame
            requestAnimationFrame(drawPFD);
        }
        
        // --- 7. COMPONENT DRAWING FUNCTIONS ---
        
        function drawAttitudeIndicator(w, h) {
            const { pitch, roll } = sensorData;
            
            ctx.save();
            ctx.translate(w / 2, h / 2);
            
            // Clamp pitch to prevent extreme movement
            const clampedPitch = Math.max(-30, Math.min(30, pitch));
            
            ctx.rotate(roll * Math.PI / 180);
            
            const pixelsPerDegree = 10;
            const pitchOffset = clampedPitch * pixelsPerDegree;

            // Sky
            ctx.fillStyle = '#0077c2';
            ctx.fillRect(-w * 2, -h * 2 + pitchOffset, w * 4, h * 2);
            
            // Ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-w * 2, 0 + pitchOffset, w * 4, h * 2);

            // Horizon Line
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-w * 2, 0 + pitchOffset);
            ctx.lineTo(w * 2, 0 + pitchOffset);
            ctx.stroke();

            // Pitch Ladder
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.font = '16px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lineLength = 100;
            const textOffset = 10;

            for (let angle = -90; angle <= 90; angle += 10) {
                if (angle === 0) continue;
                const y = -angle * pixelsPerDegree + pitchOffset;
                if (y < -h * 2 || y > h * 2) continue; // Widen draw area
                ctx.beginPath();
                ctx.moveTo(-lineLength / 2, y);
                ctx.lineTo(lineLength / 2, y);
                ctx.stroke();
                ctx.fillText(Math.abs(angle), -lineLength / 2 - textOffset - 15, y);
                ctx.fillText(Math.abs(angle),  lineLength / 2 + textOffset + 15, y);
            }
            ctx.restore();
        }

        function drawAircraftSymbol(w, h) {
            ctx.save();
            ctx.translate(w / 2, h / 2);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            
            // Main horizontal lines
            ctx.beginPath();
            ctx.moveTo(-100, 0);
            ctx.lineTo(-30, 0);
            ctx.moveTo(30, 0);
            ctx.lineTo(100, 0);
            
            // Center dot
            ctx.moveTo(0,0);
            ctx.arc(0, 0, 5, 0, 2 * Math.PI);

            // "V" part
            ctx.moveTo(-20, 15);
            ctx.lineTo(-30, 0);
            ctx.moveTo(20, 15);
            ctx.lineTo(30, 0);

            ctx.stroke();
            ctx.restore();

            // Roll Indicator (at top)
            ctx.save();
            ctx.translate(w / 2, h / 2 - 150);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('ROLL', 0, -15);

            // Digital Readout Box
            const rollBoxWidth = 80;
            const rollBoxHeight = 30;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            ctx.strokeRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            
            // Digital Readout Text
            ctx.fillStyle = '#0F0';
            ctx.font = '20px Orbitron';
            ctx.textBaseline = 'middle';
            // Clamp roll display from -180 to 180
            let displayRoll = sensorData.roll;
            if(displayRoll > 180) displayRoll -= 360;
            if(displayRoll < -180) displayRoll += 360;
            ctx.fillText(displayRoll.toFixed(1), 0, rollBoxHeight / 2);
            
            // Static pointer
            ctx.strokeStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, rollBoxHeight);
            ctx.lineTo(0, rollBoxHeight + 10);
            ctx.lineTo(-5, rollBoxHeight + 5);
            ctx.moveTo(0, rollBoxHeight + 10);
            ctx.lineTo(5, rollBoxHeight + 5);
            ctx.stroke();
            
            // Moving arc
            ctx.rotate(sensorData.roll * Math.PI / 180);
            ctx.beginPath();
            ctx.arc(0, 0, 50, (180 - 45) * Math.PI / 180, (0 + 45) * Math.PI / 180);
            ctx.stroke();

            // Arc Ticks
            const angles = [-30, -20, -10, 10, 20, 30];
            for (const angle of angles) {
                const rad = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(Math.sin(rad) * 50, -Math.cos(rad) * 50);
                ctx.lineTo(Math.sin(rad) * 60, -Math.cos(rad) * 60);
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- [REMOVED] drawHeadingIndicator ---

        function drawRollRateIndicator(w, h) {
            const { rollRate } = sensorData;
            
            // Positioned top-left
            const x = w / 2 - 210;
            const y = h / 2 - 150;
            const boxWidth = 90;
            const boxHeight = 45;
            
            ctx.save();
            
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, boxWidth, boxHeight);
            ctx.strokeRect(x, y, boxWidth, boxHeight);

            // Readout Text
            ctx.fillStyle = '#0F0';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(rollRate.toFixed(1), x + boxWidth / 2, y + boxHeight / 2 - 8);

            // Unit Label
            ctx.font = '10px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.fillText('Deg/s', x + boxWidth / 2, y + boxHeight / 2 + 12);
            ctx.restore();
        }

        // --- 8. START THE RENDER LOOP ---
        requestAnimationFrame(drawPFD);

        // === SCRIPT END ===
    </script>

</body>
</html>
