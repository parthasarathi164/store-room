<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aircraft Primary Flight Display (Simulated)</title>
    <!-- 1. Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load a good "tech" font (Orbitron) from Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    
    <style>
        /* 3. Apply the font and a dark theme */
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            background-color: #000;
            border-radius: 8px;
            border: 2px solid #333;
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-2xl font-bold text-cyan-300 mb-4">AI Primary Flight Display (SIMULATED)</h1>

    <!-- 4. The Canvas element where we will draw the PFD --><div class="w-full max-w-5xl aspect-[16/10] shadow-2xl">
        <canvas id="pfdCanvas"></canvas>
    </div>

    <!-- 5. Reverted to old status message --><p class="mt-4 text-gray-400">Simulating fake MPU6050 sensor data stream.</p>

    <script>
        // === SCRIPT START ===

        // --- 1. SETUP ---
        const canvas = document.getElementById('pfdCanvas');
        const ctx = canvas.getContext('2d');

        // --- 2. SENSOR DATA (Simulated) ---
        // This object holds the "live" data from our fake sensor
        const sensorData = {
            pitch: 0,       // Degrees
            roll: 0,        // Degrees
            rollRate: 0,    // Degrees per second
            airspeed: 120,  // Knots
            altitude: 10000, // Feet
            heading: 360,     // Degrees
            verticalSpeed: 0 // Feet per minute
        };
        
        // This object controls the *change* in our fake data
        const sim = {
            pitchRate: 0,
            rollRate: 0,
            airspeedRate: 0,
            altitudeRate: 0,
            headingRate: 0,
            verticalSpeedRate: 0,

            // Variables for smooth, noise-based simulation
            rollNoiseTime: Math.random() * 1000,
            pitchNoiseTime: Math.random() * 1000,
        };

        // --- 3. RESIZE AND INITIALIZE ---
        // (This function is unchanged)
        function resizeCanvas() {
            // Make canvas sharp on all displays
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            
            // Re-set canvas dimensions for drawing logic
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call

        // --- 4. FAKE SENSOR DATA SIMULATOR ---
        
        // This function updates the fake sensor data periodically
        function updateFakeData() {
            // Simple noise function (Perlin-like)
            function noise(time) {
                return (Math.sin(time * 0.1) + Math.sin(time * 0.23) + Math.sin(time * 0.77)) / 3;
            }

            // --- Simulate realistic, wandering roll and pitch
            sim.rollNoiseTime += 0.01;
            sim.pitchNoiseTime += 0.013;

            // Make the AI try to correct back to 0
            let rollCorrection = -sensorData.roll * 0.05;
            let pitchCorrection = -sensorData.pitch * 0.05;
            
            // Add some "human" or "turbulence" wobble
            sim.rollRate = sim.rollRate * 0.9 + (noise(sim.rollNoiseTime) * 2.0 + rollCorrection) * 0.1;
            sim.pitchRate = sim.pitchRate * 0.9 + (noise(sim.pitchNoiseTime) * 1.0 + pitchCorrection) * 0.1;

            sensorData.roll += sim.rollRate * 0.1; // 0.1 is just a time delta factor
            sensorData.pitch += sim.pitchRate * 0.1;
            
            // --- NEW: Set the rollRate data
            // We'll set this to the 'sim.rollRate' which is the *change* in roll
            // Multiplied by a factor to make it look like "degrees per second"
            sensorData.rollRate = sim.rollRate * 5; 

            // Clamp pitch and roll
            sensorData.pitch = Math.max(-90, Math.min(90, sensorData.pitch));
            sensorData.roll = Math.max(-180, Math.min(180, sensorData.roll));
            if (sensorData.roll > 180) sensorData.roll -= 360;
            if (sensorData.roll < -180) sensorData.roll += 360;
            
            // --- Simulate other instruments
            // Fluctuate airspeed around 120
            sim.airspeedRate = sim.airspeedRate * 0.8 + (Math.random() - 0.5) * 2;
            sensorData.airspeed += sim.airspeedRate * 0.1;
            sensorData.airspeed = Math.max(40, Math.min(250, sensorData.airspeed));
            
            // Fluctuate altitude
            sim.verticalSpeedRate = sim.verticalSpeedRate * 0.9 + (noise(sim.pitchNoiseTime + 100) * 100 - sensorData.verticalSpeed) * 0.1;
            sensorData.verticalSpeed += sim.verticalSpeedRate * 0.1;
            sensorData.verticalSpeed = Math.max(-3000, Math.min(3000, sensorData.verticalSpeed));
            sensorData.altitude += (sensorData.verticalSpeed / 60) * 0.05; // 33ms interval

            // Fluctuate heading
            sim.headingRate = sim.headingRate * 0.9 + (noise(sim.rollNoiseTime + 200) * 5) * 0.1;
            sensorData.heading += sim.headingRate * 0.1;
            if (sensorData.heading < 0) sensorData.heading += 360;
            if (sensorData.heading > 360) sensorData.heading -= 360;
        }

        // Start the sensor simulation
        setInterval(updateFakeData, 33); // ~30x per second


        // --- 5. MAIN DRAWING LOOP ---
        function drawPFD() {
            // Get logical width/height from styled properties
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;

            // Clear the canvas
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            // --- Call component drawing functions ---
            drawAttitudeIndicator(w, h);
            drawAircraftSymbol(w, h);
            drawAirspeedTape(w, h);
            drawAltitudeTape(w, h);
            drawHeadingIndicator(w, h);
            drawVerticalSpeedIndicator(w, h);
            drawRollRateIndicator(w, h); // This will now show the fake roll rate
            
            // Request the next frame
            requestAnimationFrame(drawPFD);
        }

        // --- 6. COMPONENT DRAWING FUNCTIONS ---
        // (These are all unchanged from the previous version)

        function drawAttitudeIndicator(w, h) {
            const { pitch, roll } = sensorData;
            
            ctx.save();
            
            // Center viewport
            ctx.translate(w / 2, h / 2);
            // Apply roll
            ctx.rotate(roll * Math.PI / 180);
            
            // --- Draw Sky and Ground ---
            const pixelsPerDegree = 10;
            const pitchOffset = pitch * pixelsPerDegree;

            // Sky (blue)
            ctx.fillStyle = '#0077c2'; // Bright sky blue
            ctx.fillRect(-w * 2, -h * 2 + pitchOffset, w * 4, h * 2);
            
            // Ground (brown)
            ctx.fillStyle = '#8B4513'; // SaddleBrown
            ctx.fillRect(-w * 2, 0 + pitchOffset, w * 4, h * 2);

            // Horizon Line
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-w * 2, 0 + pitchOffset);
            ctx.lineTo(w * 2, 0 + pitchOffset);
            ctx.stroke();

            // --- Draw Pitch Ladder ---
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.font = '16px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lineLength = 100;
            const textOffset = 10;

            for (let angle = -90; angle <= 90; angle += 10) {
                if (angle === 0) continue; // Skip horizon line
                
                const y = -angle * pixelsPerDegree + pitchOffset;
                
                // Don't draw if off-screen
                if (y < -h || y > h) continue;

                ctx.beginPath();
                ctx.moveTo(-lineLength / 2, y);
                ctx.lineTo(lineLength / 2, y);
                ctx.stroke();

                // Draw numbers
                ctx.fillText(Math.abs(angle), -lineLength / 2 - textOffset - 15, y);
                ctx.fillText(Math.abs(angle),  lineLength / 2 + textOffset + 15, y);
            }
            
            ctx.restore();
        }

        function drawAircraftSymbol(w, h) {
            // This is the static yellow symbol in the middle
            ctx.save();
            ctx.translate(w / 2, h / 2);
            
            ctx.strokeStyle = '#FFD700'; // Gold/Yellow
            ctx.lineWidth = 4;
            
            // Main horizontal lines
            ctx.beginPath();
            ctx.moveTo(-100, 0);
            ctx.lineTo(-30, 0);
            ctx.moveTo(30, 0);
            ctx.lineTo(100, 0);
            
            // Center dot
            ctx.moveTo(0,0);
            ctx.arc(0, 0, 5, 0, 2 * Math.PI);

            // "V" part
            ctx.moveTo(-20, 15);
            ctx.lineTo(-30, 0);
            ctx.moveTo(20, 15);
            ctx.lineTo(30, 0);

            ctx.stroke();
            ctx.restore();

            // --- Draw Roll Indicator ---
            ctx.save();
            ctx.translate(w / 2, h / 2 - 150); // Position at top
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;

            // --- Add ROLL label ---
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('ROLL', 0, -15); // Adjusted Y for label

            // --- NEW: Add Digital Readout Box ---
            const rollBoxWidth = 80; // Increased width
            const rollBoxHeight = 30; // Increased height
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            ctx.strokeRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            
            // --- NEW: Add Digital Readout Text ---
            ctx.fillStyle = '#0F0'; // Green text
            ctx.font = '20px Orbitron'; // Slightly larger font
            ctx.textBaseline = 'middle';
            // Display the roll, showing one decimal place
            ctx.fillText(sensorData.roll.toFixed(1), 0, rollBoxHeight / 2); // Center text vertically
            
            // Draw static pointer (below the new box)
            ctx.strokeStyle = '#FFD700'; // Match readout box
            ctx.beginPath();
            ctx.moveTo(0, rollBoxHeight); // Start at bottom of box
            ctx.lineTo(0, rollBoxHeight + 10);
            ctx.lineTo(-5, rollBoxHeight + 5);
            ctx.moveTo(0, rollBoxHeight + 10);
            ctx.lineTo(5, rollBoxHeight + 5);
            ctx.stroke();
            
            // Draw moving arc
            ctx.rotate(sensorData.roll * Math.PI / 180);
            
            // Arc
            ctx.beginPath();
            ctx.arc(0, 0, 50, (180 - 45) * Math.PI / 180, (0 + 45) * Math.PI / 180);
            ctx.stroke();

            // Ticks
            const angles = [-30, -20, -10, 10, 20, 30];
            for (const angle of angles) {
                const rad = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(Math.sin(rad) * 50, -Math.cos(rad) * 50);
                ctx.lineTo(Math.sin(rad) * 60, -Math.cos(rad) * 60);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawAirspeedTape(w, h) {
            const { airspeed } = sensorData;
            
            const tapeWidth = 80;
            const tapeHeight = h * 0.6;
            const x = w * 0.15;
            const y = (h - tapeHeight) / 2;
            const midY = y + tapeHeight / 2;

            ctx.save();
            
            // --- Draw Background and Clipping Mask ---
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip(); // Clip everything to this rectangle
            
            // --- Draw Tape Ticks and Numbers ---
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 2;

            const pixelsPerKnot = 8;

            for (let speed = Math.floor(airspeed - 50); speed <= Math.ceil(airspeed + 50); speed++) {
                if (speed < 0) continue;

                const yPos = midY - (speed - airspeed) * pixelsPerKnot;
                
                if (yPos < y - 20 || yPos > y + tapeHeight + 20) continue;

                if (speed % 10 === 0) {
                    // Major tick
                    ctx.beginPath();
                    ctx.moveTo(x + tapeWidth / 2, yPos);
                    ctx.lineTo(x + tapeWidth / 2 - 20, yPos);
                    ctx.stroke();
                    ctx.fillText(speed, x + tapeWidth / 2 - 25, yPos);
                } else if (speed % 5 === 0) {
                    // Minor tick
                    ctx.beginPath();
                    ctx.moveTo(x + tapeWidth / 2, yPos);
                    ctx.lineTo(x + tapeWidth / 2 - 10, yPos);
                    ctx.stroke();
                }
            }

            ctx.restore(); // Remove clipping mask

            // --- Draw Static Pointer and Readout Box ---
            // Pointer
            ctx.fillStyle = '#FFD700'; // Yellow
            ctx.beginPath();
            ctx.moveTo(x - tapeWidth / 2, midY);
            ctx.lineTo(x - tapeWidth / 2 + 15, midY - 10);
            ctx.lineTo(x - tapeWidth / 2 + 15, midY + 10);
            ctx.closePath();
            ctx.fill();

            // Readout Box (adjusted width and position)
            const airspeedBoxWidth = 80;
            const airspeedBoxHeight = 45; // Increased height for unit
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - tapeWidth / 2 - 5, midY - airspeedBoxHeight / 2, airspeedBoxWidth, airspeedBoxHeight);
            ctx.strokeRect(x - tapeWidth / 2 - 5, midY - airspeedBoxHeight / 2, airspeedBoxWidth, airspeedBoxHeight);

            // Readout Text
            ctx.fillStyle = '#0F0'; // Green
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(Math.round(airspeed), x - tapeWidth / 2 - 5 + airspeedBoxWidth / 2, midY - 8); // Adjusted Y

            // Add KTS label (adjusted position)
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('KTS', x - tapeWidth / 2 - 5 + airspeedBoxWidth / 2, midY + 12); // Adjusted Y
        }

        function drawAltitudeTape(w, h) {
            const { altitude } = sensorData;
            
            const tapeWidth = 80;
            const tapeHeight = h * 0.6;
            const x = w * 0.85;
            const y = (h - tapeHeight) / 2;
            const midY = y + tapeHeight / 2;

            ctx.save();
            
            // --- Draw Background and Clipping Mask ---
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip();
            
            // --- Draw Tape Ticks and Numbers ---
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 2;

            const pixelsPer100Feet = 50; // 50 pixels for every 100 feet
            const nearest100 = Math.round(altitude / 100) * 100;

            for (let alt = nearest100 - 500; alt <= nearest100 + 500; alt += 100) {
                
                const yPos = midY - (alt - altitude) / 100 * pixelsPer100Feet;
                
                if (yPos < y - 20 || yPos > y + tapeHeight + 20) continue;
                
                // Major tick
                ctx.beginPath();
                ctx.moveTo(x - tapeWidth / 2, yPos);
                ctx.lineTo(x - tapeWidth / 2 + 20, yPos);
                ctx.stroke();

                // Display in thousands and hundreds (e.g., 10,100 -> "101")
                const displayAlt = Math.abs(alt / 100);
                ctx.fillText(displayAlt, x - tapeWidth / 2 + 25, yPos);
            }
            
            ctx.restore(); // Remove clipping mask

            // --- Draw Static Pointer and Readout Box ---
            // Pointer
            ctx.fillStyle = '#FFD700'; // Yellow
            ctx.beginPath();
            ctx.moveTo(x + tapeWidth / 2, midY);
            ctx.lineTo(x + tapeWidth / 2 - 15, midY - 10);
            ctx.lineTo(x + tapeWidth / 2 - 15, midY + 10);
            ctx.closePath();
            ctx.fill();

            // Readout Box (adjusted width and height)
            const altBoxWidth = 100; // Increased width
            const altBoxHeight = 45; // Increased height for unit
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - altBoxWidth / 2, midY - altBoxHeight / 2, altBoxWidth, altBoxHeight);
            ctx.strokeRect(x - altBoxWidth / 2, midY - altBoxHeight / 2, altBoxWidth, altBoxHeight);

            // Readout Text
            ctx.fillStyle = '#0F0'; // Green
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(Math.round(altitude), x, midY - 8); // Adjusted Y

            // Add FT label (adjusted position)
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('FT', x, midY + 12); // Adjusted Y
        }

        function drawHeadingIndicator(w, h) {
            const { heading } = sensorData;
            
            const tapeWidth = w * 0.4;
            const tapeHeight = 60;
            const x = w / 2;
            const y = h * 0.85;

            ctx.save();
            
            // --- Draw Background and Clipping Mask ---
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip();
            
            // --- Draw Tape Ticks and Numbers ---
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '18px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.lineWidth = 2;

            const pixelsPerDegree = 5;
            const headings = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };

            for (let deg = -360; deg <= 720; deg += 10) {
                const xPos = x - (deg - heading) * pixelsPerDegree;
                
                if (xPos < x - tapeWidth / 2 - 50 || xPos > x + tapeWidth / 2 + 50) continue;

                let displayDeg = deg;
                while(displayDeg < 0) displayDeg += 360;
                while(displayDeg >= 360) displayDeg -= 360;

                if (displayDeg % 90 === 0) { // N, E, S, W
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 25);
                    ctx.stroke();
                    ctx.fillText(headings[displayDeg], xPos, y + 30);
                } else if (displayDeg % 30 === 0) { // Numbers (e.g., 3, 6, 12, 15)
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 25);
                    ctx.stroke();
                    ctx.fillText(displayDeg / 10, xPos, y + 30);
                } else { // 10-degree ticks
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 15);
                    ctx.stroke();
                }
            }
            
            ctx.restore(); // Remove clipping mask

            // --- Draw Static Pointer and Readout Box ---
            // Pointer
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 10, y + 15);
            ctx.lineTo(x + 10, y + 15);
            ctx.closePath();
            ctx.fill();

            // Readout Box (adjusted width and height)
            const headingBoxWidth = 80;
            const headingBoxHeight = 45; // Increased height for unit
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - headingBoxWidth / 2, y - headingBoxHeight - 5, headingBoxWidth, headingBoxHeight); // Adjusted Y for box
            ctx.strokeRect(x - headingBoxWidth / 2, y - headingBoxHeight - 5, headingBoxWidth, headingBoxHeight);

            // Readout Text
            ctx.fillStyle = '#0F0';
            ctx.font = '22px Orbitron';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(String(Math.round(heading)).padStart(3, '0'), x, y - headingBoxHeight / 2 - 5 - 8); // Adjusted Y

            // Add HDG label (adjusted position)
            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('HDG', x, y - headingBoxHeight / 2 - 5 + 12); // Adjusted Y
        }

        function drawVerticalSpeedIndicator(w, h) {
            const { verticalSpeed } = sensorData;

            const vsWidth = 40;
            const vsHeight = h * 0.4;
            const x = w * 0.85 + 70; // Position right of Altimeter
            const y = (h - vsHeight) / 2;
            const midY = y + vsHeight / 2;
            
            ctx.save();
            
            // --- NEW: Add V/S Label ---
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('V/S', x + vsWidth / 2, y - 15); // Adjusted Y for label
            
            // Background
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x, y, vsWidth, vsHeight);
            
            // Center Line
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + vsWidth / 2, y + 20);
            ctx.lineTo(x + vsWidth / 2, y + vsHeight - 20);
            ctx.stroke();

            // Ticks (simple version)
            const ticks = [-2000, -1000, 1000, 2000];
            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            for (const vs of ticks) {
                const yPos = midY - (vs / 2000) * (vsHeight / 2 - 30);
                ctx.beginPath();
                ctx.moveTo(x + vsWidth / 2 - 5, yPos);
                ctx.lineTo(x + vsWidth / 2 + 5, yPos);
                ctx.stroke();
                ctx.fillText(Math.abs(vs / 1000), x + vsWidth / 2 + 10, yPos);
            }
            ctx.fillText('0', x + vsWidth / 2 + 10, midY);
            
            // Pointer
            const maxVs = 3000; // Clamp pointer travel
            const clampedVs = Math.max(-maxVs, Math.min(maxVs, verticalSpeed));
            const pointerY = midY - (clampedVs / maxVs) * (vsHeight / 2 - 30);

            ctx.fillStyle = '#0F0';
            ctx.beginPath();
            ctx.moveTo(x, pointerY);
            ctx.lineTo(x + vsWidth / 2, pointerY - 5);
            ctx.lineTo(x + vsWidth / 2, pointerY + 5);
            ctx.closePath();
            ctx.fill();

            // --- NEW: Add x1000 Label ---
            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('x1000', x + vsWidth / 2, y + vsHeight + 15); // Label below

            ctx.restore();
        }
        
        // --- 7. NEW: ROLL RATE INDICATOR ---
        function drawRollRateIndicator(w, h) {
            const { rollRate } = sensorData;
            
            // Position it in the top-right, near the roll indicator
            const x = w / 2 + 120; 
            const y = h / 2 - 150;
            const boxWidth = 90;
            const boxHeight = 45;

            ctx.save();
            
            // Box
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFF'; // White border to distinguish from primary readouts
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, boxWidth, boxHeight);
            ctx.strokeRect(x, y, boxWidth, boxHeight);

            // Readout Text (Number)
            ctx.fillStyle = '#0F0'; // Green
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(rollRate.toFixed(1), x + boxWidth / 2, y + boxHeight / 2 - 8); // Number adjusted up

            // Add "Deg/s" unit below
            ctx.font = '10px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.fillText('Deg/s', x + boxWidth / 2, y + boxHeight / 2 + 12); // Unit adjusted down
            
            ctx.restore();
        }


        // --- 8. START THE RENDER LOOP ---
        requestAnimationFrame(drawPFD);

        // === SCRIPT END ===
    </script>

</body>
</html>
