<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aircraft Primary Flight Display (Live Data)</title>
    <!-- 1. Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load a good "tech" font (Orbitron) from Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    
    <style>
        /* 3. Apply the font and a dark theme */
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            background-color: #000;
            border-radius: 8px;
            border: 2px solid #333;
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-2xl font-bold text-cyan-300 mb-4">AI Primary Flight Display (LIVE DATA)</h1>

    <!-- 4. The Canvas element where we will draw the PFD --><div class="w-full max-w-5xl aspect-[16/10] shadow-2xl">
        <canvas id="pfdCanvas"></canvas>
    </div>

    <!-- 5. NEW: Connection Button and Status Message -->
    <button id="connectButton" class="mt-4 px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700 transition duration-300">
        Connect to Nucleo Board
    </button>
    <p id="statusMessage" class="mt-4 text-gray-400">Status: Disconnected</p>


    <script>
        // === SCRIPT START ===

        // --- 1. SETUP ---
        const canvas = document.getElementById('pfdCanvas');
        const ctx = canvas.getContext('2d');
        const connectButton = document.getElementById('connectButton');
        const statusMessage = document.getElementById('statusMessage');

        // --- 2. SENSOR DATA ---
        // This object holds the "live" data
        const sensorData = {
            pitch: 0,       // Degrees (From Nucleo)
            roll: 0,        // Degrees (From Nucleo)
            rollRate: 0,    // Degrees per second (From Nucleo)
            airspeed: 120,  // Knots (Simulated)
            altitude: 10000, // Feet (Simulated)
            heading: 360,     // Degrees (Simulated)
            verticalSpeed: 0 // Feet per minute (Simulated)
        };
        
        // This object controls the *change* in our FAKE data (for other instruments)
        const sim = {
            pitchRate: 0,
            rollRate: 0,
            airspeedRate: 0,
            altitudeRate: 0,
            headingRate: 0,
            verticalSpeedRate: 0,
            rollNoiseTime: Math.random() * 1000,
            pitchNoiseTime: Math.random() * 1000,
        };
        
        // --- 3. WEB SERIAL API ---
        let port;
        let reader;
        let lineBuffer = ''; // Holds incomplete data from the serial port

        connectButton.addEventListener('click', async () => {
            if (port) {
                // If already connected, disconnect
                await reader.cancel();
                await port.close();
                port = null;
                reader = null;
                statusMessage.textContent = 'Status: Disconnected';
                connectButton.textContent = 'Connect to Nucleo Board';
                connectButton.classList.replace('bg-red-600', 'bg-blue-600');
                connectButton.classList.replace('hover:bg-red-700', 'hover:bg-blue-700');
            } else {
                // Not connected, so let's connect
                try {
                    // Prompt user to select a serial port
                    port = await navigator.serial.requestPort();
                    // Open the port
                    await port.open({ baudRate: 115200 }); // Must match your Nucleo's baud rate

                    statusMessage.textContent = 'Status: Connecting...';
                    
                    // Set up the text decoder and reader
                    const textDecoder = new TextDecoderStream();
                    const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
                    reader = textDecoder.readable.getReader();

                    // Update UI
                    connectButton.textContent = 'Disconnect';
                    connectButton.classList.replace('bg-blue-600', 'bg-red-600');
                    connectButton.classList.replace('hover:bg-blue-700', 'hover:bg-red-700');
                    statusMessage.textContent = 'Status: Connected! Waiting for data...';

                    // Start the read loop
                    readSerialLoop();

                } catch (error) {
                    console.error('There was an error connecting to the serial port:', error);
                    statusMessage.textContent = `Error: ${error.message}`;
                }
            }
        });

        async function readSerialLoop() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        // Reader has been canceled
                        break;
                    }
                    
                    // Add new data to our line buffer
                    lineBuffer += value;

                    // Check for newline characters, which mark the end of a JSON message
                    let newlineIndex;
                    while ((newlineIndex = lineBuffer.indexOf('\n')) !== -1) {
                        // We found a complete line
                        const completeLine = lineBuffer.substring(0, newlineIndex + 1);
                        lineBuffer = lineBuffer.substring(newlineIndex + 1); // Save the rest for next time

                        // Try to parse the complete line as JSON
                        try {
                            const jsonData = JSON.parse(completeLine);
                            
                            // *** THIS IS THE MAGIC ***
                            // Update our sensorData object with the LIVE data
                            if (jsonData.pitch !== undefined) {
                                sensorData.pitch = jsonData.pitch;
                            }
                            if (jsonData.roll !== undefined) {
                                sensorData.roll = jsonData.roll;
                            }
                            if (jsonData.rollRate !== undefined) {
                                sensorData.rollRate = jsonData.rollRate;
                            }
                            
                            if (statusMessage.textContent !== 'Status: Receiving Live Data') {
                                statusMessage.textContent = 'Status: Receiving Live Data';
                                statusMessage.classList.add('text-green-400');
                            }

                        } catch (e) {
                            console.warn('Serial Read: Could not parse JSON line:', completeLine, e);
                            // Ignore lines that aren't valid JSON
                        }
                    }
                }
            } catch (error) {
                console.error('Read loop error:', error);
                statusMessage.textContent = `Error: ${error.message}`;
            } finally {
                if (reader) {
                    reader.releaseLock();
                }
            }
        }


        // --- 4. RESIZE AND INITIALIZE ---
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 5. FAKE SENSOR DATA SIMULATOR (Partial) ---
        // This function NOW ONLY updates the instruments we
        // are NOT getting from the Nucleo board.
        function updateFakeData() {
            // Simple noise function
            function noise(time) {
                return (Math.sin(time * 0.1) + Math.sin(time * 0.23) + Math.sin(time * 0.77)) / 3;
            }
            
            sim.pitchNoiseTime += 0.013;
            sim.rollNoiseTime += 0.01;

            // --- PITCH, ROLL, and ROLL RATE ARE NOW CONTROLLED BY THE NUCLEO ---
            // We have REMOVED the simulation logic for pitch, roll, and rollRate.
            
            // --- Simulate other instruments (Unchanged)
            // Fluctuate airspeed around 120
            sim.airspeedRate = sim.airspeedRate * 0.8 + (Math.random() - 0.5) * 2;
            sensorData.airspeed += sim.airspeedRate * 0.1;
            sensorData.airspeed = Math.max(40, Math.min(250, sensorData.airspeed));
            
            // Fluctuate altitude
            sim.verticalSpeedRate = sim.verticalSpeedRate * 0.9 + (noise(sim.pitchNoiseTime + 100) * 100 - sensorData.verticalSpeed) * 0.1;
            sensorData.verticalSpeed += sim.verticalSpeedRate * 0.1;
            sensorData.verticalSpeed = Math.max(-3000, Math.min(3000, sensorData.verticalSpeed));
            sensorData.altitude += (sensorData.verticalSpeed / 60) * 0.05;

            // Fluctuate heading
            sim.headingRate = sim.headingRate * 0.9 + (noise(sim.rollNoiseTime + 200) * 5) * 0.1;
            sensorData.heading += sim.headingRate * 0.1;
            if (sensorData.heading < 0) sensorData.heading += 360;
            if (sensorData.heading > 360) sensorData.heading -= 360;
        }

        // Start the sensor simulation (for the non-Nucleo instruments)
        setInterval(updateFakeData, 33); // ~30x per second


        // --- 6. MAIN DRAWING LOOP ---
        function drawPFD() {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;

            // Clear the canvas
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            
            // --- Call component drawing functions ---
            drawAttitudeIndicator(w, h);
            drawAircraftSymbol(w, h);
            drawAirspeedTape(w, h);
            drawAltitudeTape(w, h);
            drawHeadingIndicator(w, h);
            drawVerticalSpeedIndicator(w, h);
            drawRollRateIndicator(w, h);
            
            // Request the next frame
            requestAnimationFrame(drawPFD);
        }

        // --- 7. COMPONENT DRAWING FUNCTIONS ---
        // (These are all unchanged from your original file)
        function drawAttitudeIndicator(w, h) {
            const { pitch, roll } = sensorData;
            
            ctx.save();
            ctx.translate(w / 2, h / 2);
            ctx.rotate(roll * Math.PI / 180);
            
            const pixelsPerDegree = 10;
            const pitchOffset = pitch * pixelsPerDegree;

            // Sky
            ctx.fillStyle = '#0077c2';
            ctx.fillRect(-w * 2, -h * 2 + pitchOffset, w * 4, h * 2);
            
            // Ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-w * 2, 0 + pitchOffset, w * 4, h * 2);

            // Horizon Line
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-w * 2, 0 + pitchOffset);
            ctx.lineTo(w * 2, 0 + pitchOffset);
            ctx.stroke();

            // Pitch Ladder
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.font = '16px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lineLength = 100;
            const textOffset = 10;

            for (let angle = -90; angle <= 90; angle += 10) {
                if (angle === 0) continue;
                const y = -angle * pixelsPerDegree + pitchOffset;
                if (y < -h || y > h) continue;
                ctx.beginPath();
                ctx.moveTo(-lineLength / 2, y);
                ctx.lineTo(lineLength / 2, y);
                ctx.stroke();
                ctx.fillText(Math.abs(angle), -lineLength / 2 - textOffset - 15, y);
                ctx.fillText(Math.abs(angle),  lineLength / 2 + textOffset + 15, y);
            }
            ctx.restore();
        }

        function drawAircraftSymbol(w, h) {
            ctx.save();
            ctx.translate(w / 2, h / 2);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            
            ctx.beginPath();
            ctx.moveTo(-100, 0);
            ctx.lineTo(-30, 0);
            ctx.moveTo(30, 0);
            ctx.lineTo(100, 0);
            ctx.moveTo(0,0);
            ctx.arc(0, 0, 5, 0, 2 * Math.PI);
            ctx.moveTo(-20, 15);
            ctx.lineTo(-30, 0);
            ctx.moveTo(20, 15);
            ctx.lineTo(30, 0);
            ctx.stroke();
            ctx.restore();

            // Roll Indicator
            ctx.save();
            ctx.translate(w / 2, h / 2 - 150);
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('ROLL', 0, -15);

            const rollBoxWidth = 80;
            const rollBoxHeight = 30;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            ctx.strokeRect(-rollBoxWidth / 2, 0, rollBoxWidth, rollBoxHeight);
            
            ctx.fillStyle = '#0F0';
            ctx.font = '20px Orbitron';
            ctx.textBaseline = 'middle';
            ctx.fillText(sensorData.roll.toFixed(1), 0, rollBoxHeight / 2);
            
            ctx.strokeStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, rollBoxHeight);
            ctx.lineTo(0, rollBoxHeight + 10);
            ctx.lineTo(-5, rollBoxHeight + 5);
            ctx.moveTo(0, rollBoxHeight + 10);
            ctx.lineTo(5, rollBoxHeight + 5);
            ctx.stroke();
            
            ctx.rotate(sensorData.roll * Math.PI / 180);
            ctx.beginPath();
            ctx.arc(0, 0, 50, (180 - 45) * Math.PI / 180, (0 + 45) * Math.PI / 180);
            ctx.stroke();

            const angles = [-30, -20, -10, 10, 20, 30];
            for (const angle of angles) {
                const rad = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(Math.sin(rad) * 50, -Math.cos(rad) * 50);
                ctx.lineTo(Math.sin(rad) * 60, -Math.cos(rad) * 60);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawAirspeedTape(w, h) {
            const { airspeed } = sensorData;
            const tapeWidth = 80;
            const tapeHeight = h * 0.6;
            const x = w * 0.15;
            const y = (h - tapeHeight) / 2;
            const midY = y + tapeHeight / 2;
            ctx.save();
            
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip();
            
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 2;
            const pixelsPerKnot = 8;

            for (let speed = Math.floor(airspeed - 50); speed <= Math.ceil(airspeed + 50); speed++) {
                if (speed < 0) continue;
                const yPos = midY - (speed - airspeed) * pixelsPerKnot;
                if (yPos < y - 20 || yPos > y + tapeHeight + 20) continue;

                if (speed % 10 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(x + tapeWidth / 2, yPos);
                    ctx.lineTo(x + tapeWidth / 2 - 20, yPos);
                    ctx.stroke();
                    ctx.fillText(speed, x + tapeWidth / 2 - 25, yPos);
                } else if (speed % 5 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(x + tapeWidth / 2, yPos);
                    ctx.lineTo(x + tapeWidth / 2 - 10, yPos);
                    ctx.stroke();
                }
            }
            ctx.restore();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x - tapeWidth / 2, midY);
            ctx.lineTo(x - tapeWidth / 2 + 15, midY - 10);
            ctx.lineTo(x - tapeWidth / 2 + 15, midY + 10);
            ctx.closePath();
            ctx.fill();

            const airspeedBoxWidth = 80;
            const airspeedBoxHeight = 45;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - tapeWidth / 2 - 5, midY - airspeedBoxHeight / 2, airspeedBoxWidth, airspeedBoxHeight);
            ctx.strokeRect(x - tapeWidth / 2 - 5, midY - airspeedBoxHeight / 2, airspeedBoxWidth, airspeedBoxHeight);

            ctx.fillStyle = '#0F0';
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(Math.round(airspeed), x - tapeWidth / 2 - 5 + airspeedBoxWidth / 2, midY - 8);

            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('KTS', x - tapeWidth / 2 - 5 + airspeedBoxWidth / 2, midY + 12);
        }

        function drawAltitudeTape(w, h) {
            const { altitude } = sensorData;
            const tapeWidth = 80;
            const tapeHeight = h * 0.6;
            const x = w * 0.85;
            const y = (h - tapeHeight) / 2;
            const midY = y + tapeHeight / 2;
            ctx.save();
            
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip();
            
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 2;
            const pixelsPer100Feet = 50;
            const nearest100 = Math.round(altitude / 100) * 100;

            for (let alt = nearest100 - 500; alt <= nearest100 + 500; alt += 100) {
                const yPos = midY - (alt - altitude) / 100 * pixelsPer100Feet;
                if (yPos < y - 20 || yPos > y + tapeHeight + 20) continue;
                ctx.beginPath();
                ctx.moveTo(x - tapeWidth / 2, yPos);
                ctx.lineTo(x - tapeWidth / 2 + 20, yPos);
                ctx.stroke();
                const displayAlt = Math.abs(alt / 100);
                ctx.fillText(displayAlt, x - tapeWidth / 2 + 25, yPos);
            }
            ctx.restore();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x + tapeWidth / 2, midY);
            ctx.lineTo(x + tapeWidth / 2 - 15, midY - 10);
            ctx.lineTo(x + tapeWidth / 2 - 15, midY + 10);
            ctx.closePath();
            ctx.fill();

            const altBoxWidth = 100;
            const altBoxHeight = 45;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - altBoxWidth / 2, midY - altBoxHeight / 2, altBoxWidth, altBoxHeight);
            ctx.strokeRect(x - altBoxWidth / 2, midY - altBoxHeight / 2, altBoxWidth, altBoxHeight);

            ctx.fillStyle = '#0F0';
            ctx.font = '24px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(Math.round(altitude), x, midY - 8);

            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('FT', x, midY + 12);
        }

        function drawHeadingIndicator(w, h) {
            const { heading } = sensorData;
            const tapeWidth = w * 0.4;
            const tapeHeight = 60;
            const x = w / 2;
            const y = h * 0.85;
            ctx.save();
            
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.beginPath();
            ctx.rect(x - tapeWidth / 2, y, tapeWidth, tapeHeight);
            ctx.clip();
            
            ctx.strokeStyle = '#FFF';
            ctx.fillStyle = '#FFF';
            ctx.font = '18px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.lineWidth = 2;

            const pixelsPerDegree = 5;
            const headings = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };

            for (let deg = -360; deg <= 720; deg += 10) {
                const xPos = x - (deg - heading) * pixelsPerDegree;
                if (xPos < x - tapeWidth / 2 - 50 || xPos > x + tapeWidth / 2 + 50) continue;
                let displayDeg = deg;
                while(displayDeg < 0) displayDeg += 360;
                while(displayDeg >= 360) displayDeg -= 360;

                if (displayDeg % 90 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 25);
                    ctx.stroke();
                    ctx.fillText(headings[displayDeg], xPos, y + 30);
                } else if (displayDeg % 30 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 25);
                    ctx.stroke();
                    ctx.fillText(displayDeg / 10, xPos, y + 30);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + 15);
                    ctx.stroke();
                }
            }
            ctx.restore();

            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 10, y + 15);
            ctx.lineTo(x + 10, y + 15);
            ctx.closePath();
            ctx.fill();

            const headingBoxWidth = 80;
            const headingBoxHeight = 45;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.fillRect(x - headingBoxWidth / 2, y - headingBoxHeight - 5, headingBoxWidth, headingBoxHeight);
            ctx.strokeRect(x - headingBoxWidth / 2, y - headingBoxHeight - 5, headingBoxWidth, headingBoxHeight);

            ctx.fillStyle = '#0F0';
            ctx.font = '22px Orbitron';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(String(Math.round(heading)).padStart(3, '0'), x, y - headingBoxHeight / 2 - 5 - 8);

            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('HDG', x, y - headingBoxHeight / 2 - 5 + 12);
        }

        function drawVerticalSpeedIndicator(w, h) {
            const { verticalSpeed } = sensorData;
            const vsWidth = 40;
            const vsHeight = h * 0.4;
            const x = w * 0.85 + 70;
            const y = (h - vsHeight) / 2;
            const midY = y + vsHeight / 2;
            ctx.save();
            
            ctx.font = '14px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('V/S', x + vsWidth / 2, y - 15);
            
            ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(x, y, vsWidth, vsHeight);
            
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + vsWidth / 2, y + 20);
            ctx.lineTo(x + vsWidth / 2, y + vsHeight - 20);
            ctx.stroke();

            const ticks = [-2000, -1000, 1000, 2000];
            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            for (const vs of ticks) {
                const yPos = midY - (vs / 2000) * (vsHeight / 2 - 30);
                ctx.beginPath();
                ctx.moveTo(x + vsWidth / 2 - 5, yPos);
                ctx.lineTo(x + vsWidth / 2 + 5, yPos);
                ctx.stroke();
                ctx.fillText(Math.abs(vs / 1000), x + vsWidth / 2 + 10, yPos);
            }
            ctx.fillText('0', x + vsWidth / 2 + 10, midY);
            
            const maxVs = 3000;
            const clampedVs = Math.max(-maxVs, Math.min(maxVs, verticalSpeed));
            const pointerY = midY - (clampedVs / maxVs) * (vsHeight / 2 - 30);
            ctx.fillStyle = '#0F0';
            ctx.beginPath();
            ctx.moveTo(x, pointerY);
            ctx.lineTo(x + vsWidth / 2, pointerY - 5);
            ctx.lineTo(x + vsWidth / 2, pointerY + 5);
            ctx.closePath();
            ctx.fill();

            ctx.font = '12px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.textAlign = 'center';
            ctx.fillText('x1000', x + vsWidth / 2, y + vsHeight + 15);
            ctx.restore();
        }
        
        function drawRollRateIndicator(w, h) {
            const { rollRate } = sensorData;
            const x = w / 2 + 120; 
            const y = h / 2 - 150;
            const boxWidth = 90;
            const boxHeight = 45;
            ctx.save();
            
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.fillRect(x, y, boxWidth, boxHeight);
            ctx.strokeRect(x, y, boxWidth, boxHeight);

            ctx.fillStyle = '#0F0';
            ctx.font = '20px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(rollRate.toFixed(1), x + boxWidth / 2, y + boxHeight / 2 - 8);

            ctx.font = '10px Orbitron';
            ctx.fillStyle = '#FFF';
            ctx.fillText('Deg/s', x + boxWidth / 2, y + boxHeight / 2 + 12);
            ctx.restore();
        }

        // --- 8. START THE RENDER LOOP ---
        requestAnimationFrame(drawPFD);

        // === SCRIPT END ===
    </script>

</body>
</html>
