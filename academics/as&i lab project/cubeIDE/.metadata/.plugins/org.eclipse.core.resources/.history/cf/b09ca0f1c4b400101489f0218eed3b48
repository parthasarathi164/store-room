/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body (MPU6050 JSON Output)
  ******************************************************************************
  * @attention
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_I2C1_Init(void);

/* USER CODE BEGIN 0 */

// MPU6050 Definitions
#define MPU6050_ADDR         (0x68 << 1)
#define MPU6050_PWR_MGMT_1   0x6B
#define MPU6050_SMPLRT_DIV   0x19
#define MPU6050_CONFIG       0x1A
#define MPU6050_GYRO_CONFIG  0x1B
#define MPU6050_ACCEL_CONFIG 0x1C
#define MPU6050_ACCEL_XOUT_H 0x3B

#define ACCEL_SENS_2G        16384.0f
#define GYRO_SENS_250DPS     131.0f
#define COMPLEMENTARY_ALPHA  0.98f

char txbuf[128];
float angle_roll = 0.0f, angle_pitch = 0.0f;
uint32_t last_tick = 0;

// I2C read helper
static HAL_StatusTypeDef mpu_read(uint8_t reg, uint8_t *buf, uint16_t len) {
    return HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, reg, I2C_MEMADD_SIZE_8BIT, buf, len, 100);
}

// MPU6050 init
static int mpu6050_init(void) {
    uint8_t data;

    data = 0x00; // Wake up
    if (HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU6050_PWR_MGMT_1, I2C_MEMADD_SIZE_8BIT, &data, 1, 100) != HAL_OK)
        return -1;

    data = 9; // 100Hz
    HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU6050_SMPLRT_DIV, I2C_MEMADD_SIZE_8BIT, &data, 1, 100);

    data = 3; // DLPF
    HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU6050_CONFIG, I2C_MEMADD_SIZE_8BIT, &data, 1, 100);

    data = 0x00; // ±250 dps
    HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU6050_GYRO_CONFIG, I2C_MEMADD_SIZE_8BIT, &data, 1, 100);

    data = 0x00; // ±2g
    HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, MPU6050_ACCEL_CONFIG, I2C_MEMADD_SIZE_8BIT, &data, 1, 100);

    HAL_Delay(50);
    return 0;
}

// Read raw data
static int mpu6050_read(float *ax, float *ay, float *az, float *gx, float *gy, float *gz) {
    uint8_t raw[14];
    if (mpu_read(MPU6050_ACCEL_XOUT_H, raw, 14) != HAL_OK) return -1;

    int16_t raw_ax = (raw[0] << 8) | raw[1];
    int16_t raw_ay = (raw[2] << 8) | raw[3];
    int16_t raw_az = (raw[4] << 8) | raw[5];
    int16_t raw_gx = (raw[8] << 8) | raw[9];
    int16_t raw_gy = (raw[10] << 8) | raw[11];
    int16_t raw_gz = (raw[12] << 8) | raw[13];

    *ax = raw_ax / ACCEL_SENS_2G;
    *ay = raw_ay / ACCEL_SENS_2G;
    *az = raw_az / ACCEL_SENS_2G;

    *gx = raw_gx / GYRO_SENS_250DPS;
    *gy = raw_gy / GYRO_SENS_250DPS;
    *gz = raw_gz / GYRO_SENS_250DPS;

    return 0;
}

/* USER CODE END 0 */

int main(void)
{
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_I2C1_Init();

  /* USER CODE BEGIN 2 */

  /*if (mpu6050_init() != 0) {
      const char *err = "MPU6050 init failed\r\n";
      HAL_UART_Transmit(&huart2, (uint8_t*)err, strlen(err), 100);
      while (1);
  }*/

  HAL_Delay(100);

  float ax, ay, az, gx, gy, gz;
  if (mpu6050_read(&ax, &ay, &az, &gx, &gy, &gz) == 0) {
      angle_roll = atan2f(ay, az) * 180.0f / M_PI;
      angle_pitch = atan2f(-ax, sqrtf(ay*ay + az*az)) * 180.0f / M_PI;
  }
  last_tick = HAL_GetTick();

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
      /*uint32_t now = HAL_GetTick();
      float dt = (now - last_tick) / 1000.0f;
      if (dt <= 0) dt = 0.01f;
      last_tick = now;

      if (mpu6050_read(&ax, &ay, &az, &gx, &gy, &gz) != 0) {
          HAL_Delay(5);
          continue;
      }

      float roll_rate = gx;
      float pitch_rate = gy;
      float yaw_rate = gz;

      float accel_roll  = atan2f(ay, az) * 180.0f / M_PI;
      float accel_pitch = atan2f(-ax, sqrtf(ay*ay + az*az)) * 180.0f / M_PI;

      float gyro_roll = angle_roll + roll_rate * dt;
      float gyro_pitch = angle_pitch + pitch_rate * dt;

      angle_roll  = COMPLEMENTARY_ALPHA * gyro_roll  + (1.0f - COMPLEMENTARY_ALPHA) * accel_roll;
      angle_pitch = COMPLEMENTARY_ALPHA * gyro_pitch + (1.0f - COMPLEMENTARY_ALPHA) * accel_pitch;

      static float heading = 0.0f;
      heading += yaw_rate * dt;
      if (heading >= 360) heading -= 360;
      if (heading < 0) heading += 360;

      int len = snprintf(txbuf, sizeof(txbuf),
          "{\"pitch\":%.2f,\"roll\":%.2f,\"rollRate\":%.2f,\"heading\":%.1f}\r\n",
          angle_pitch, angle_roll, roll_rate, heading);

      HAL_UART_Transmit(&huart2, (uint8_t*)txbuf, len, 50);

      HAL_Delay(10);*/
	  uint8_t i;
	  char msg[64];
	  for (i = 1; i < 127; i++) {
	      if (HAL_I2C_IsDeviceReady(&hi2c1, (i << 1), 1, 10) == HAL_OK) {
	          snprintf(msg, sizeof(msg), "I2C device found at 0x%02X\r\n", i);
	          HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);
	      }
	  }
	  HAL_UART_Transmit(&huart2, (uint8_t*)"Scan done\r\n", 11, 100);
	  while(1);

  }
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
}
/* USER CODE END 3 */

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) Error_Handler();

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
      Error_Handler();
}

static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
    Error_Handler();
}

static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
    Error_Handler();
}

static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
